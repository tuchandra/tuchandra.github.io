<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>
        Smart Join Algorithms for Fighting Skew at Scale - Tushar Chandra
      </title>
    <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  
  <meta name="theme-color" content="#000000" />
  <meta http-equiv="window-target" content="_top" />
  
  <meta name="description" content="Speaker: Andrew Clegg (Applied ML Group @ Yelp).
" />
  <meta name="generator" content="Hugo 0.62.0 with theme pure" />
  <title>Smart Join Algorithms for Fighting Skew at Scale - Tushar Chandra</title>
  

  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
  <meta property="og:title" content="Smart Join Algorithms for Fighting Skew at Scale" />
<meta property="og:description" content="Speaker: Andrew Clegg (Applied ML Group @ Yelp)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/spark/smart_join.html" />
<meta property="article:published_time" content="2019-04-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-04-24T00:00:00+00:00" />
<meta itemprop="name" content="Smart Join Algorithms for Fighting Skew at Scale">
<meta itemprop="description" content="Speaker: Andrew Clegg (Applied ML Group @ Yelp).">
<meta itemprop="datePublished" content="2019-04-24T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-04-24T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1333">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Smart Join Algorithms for Fighting Skew at Scale"/>
<meta name="twitter:description" content="Speaker: Andrew Clegg (Applied ML Group @ Yelp)."/>
</head>
  </head>
  

  <body class="main-center theme-blue" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar">
            <img class="img-circle" src="/headshot.jpg" width="300" height="300">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm"><b>Tushar Chandra</b></h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md">Data Scientist</h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Chicago, IL</small>
        </div>

        
        <nav id="mobile-navbar" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
          <ul class="mobile-nav">
              <a href="/">
                <li class="menu-item-home">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">Home</span>
                </li>
              </a>
              <a href="/about">
                <li class="menu-item-about">
                    <i class="icon icon-cup-fill"></i>
                  <span class="menu-title">About</span>
                </li>
              </a>
              <a href="/resume">
                <li class="menu-item-resume">
                    <i class="icon icon-file"></i>
                  <span class="menu-title">Resume</span>
                </li>
              </a>
              <a href="/categories.html">
                <li class="menu-item-categories">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">Categories</span>
                </li>
              </a>
              <a href="/posts.html">
                <li class="menu-item-archives">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">Archives</span>
                </li>
              </a>

          </ul>
        </nav>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">Home</span>
                </a>
            </li>
            <li class="menu-item menu-item-about">
                <a href="/about">
                    <i class="icon icon-cup-fill"></i>
                  <span class="menu-title">About</span>
                </a>
            </li>
            <li class="menu-item menu-item-resume">
                <a href="/resume">
                    <i class="icon icon-file"></i>
                  <span class="menu-title">Resume</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/categories.html">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">Categories</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/posts.html">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">Archives</span>
                </a>
            </li>

        </ul>
      </nav>
    </div>
  </header>
<aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <div class="widget">
    <h3 class="widget-title"> Categories</h3>
    <div class="widget-body">
        <ul class="category-list">
            <li class="category-list-item"><a href="/categories/about.html" class="category-list-link">about</a><span class="category-list-count">2</span></li>
            <li class="category-list-item"><a href="/categories/general.html" class="category-list-link">general</a><span class="category-list-count">14</span></li>
            <li class="category-list-item"><a href="/categories/papers.html" class="category-list-link">papers</a><span class="category-list-count">11</span></li>
            <li class="category-list-item"><a href="/categories/spark.html" class="category-list-link">spark</a><span class="category-list-count">13</span></li>
            <li class="category-list-item"><a href="/categories/what-i-read.html" class="category-list-link">what-i-read</a><span class="category-list-count">4</span></li>
        </ul>
    </div>
</div>
<div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="/papers/discrimination_algorithms_kleinberg_2.html" class="title">Paper: Discrimination in the Age of Algorithms (2/2)</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2019-12-30 00:00:00 &#43;0000 UTC" itemprop="datePublished">2019-12-30</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="/papers/discrimination_algorithms_kleinberg_1.html" class="title">Paper: Discrimination in the Age of Algorithms (1/2)</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2019-12-29 00:00:00 &#43;0000 UTC" itemprop="datePublished">2019-12-29</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="/posts/talk_aguera_neurips.html" class="title">Blaise Aguera y Arcas: Social Intelligence (NeurIPS 2019)</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2019-12-28 00:00:00 &#43;0000 UTC" itemprop="datePublished">2019-12-28</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="/what_i_read/20191228.html" class="title">What I read this week (December 22 - 28)</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2019-12-28 00:00:00 &#43;0000 UTC" itemprop="datePublished">2019-12-28</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="/posts/talk_kidd_neurips.html" class="title">Celeste Kidd: How to Know (NeurIPS 2019)</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2019-12-27 00:00:00 &#43;0000 UTC" itemprop="datePublished">2019-12-27</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/spark/smart_join.html"
    >Smart Join Algorithms for Fighting Skew at Scale</a
  >
</h1>

      <div class="article-meta">
        <span class="article-date">
  <i class="icon icon-calendar-check"></i>
<a href="/spark/smart_join.html" class="article-date">
  <time datetime="2019-04-24 00:00:00 &#43;0000 UTC" itemprop="datePublished">2019-04-24</time>
</a>
</span><span class="article-category">
  <i class="icon icon-folder"></i>
  <a class="article-category-link" href="/categories/spark.html"> spark </a>
</span>

        
      </div>
    </div>
    <div class="article-entry marked-body js-toc-content" itemprop="articleBody">
      <p>Speaker: Andrew Clegg (Applied ML Group @ Yelp).</p>
<p>Slides available <a href="https://drive.google.com/file/d/1D5vWUAjZBKHmF1uFT--a_U1n8nW3z9Ac/view">here</a>.</p>
<hr>
<h2 id="data-skew">Data skew</h2>
<p>Everyone knows the classical statistical definitions of skew, where the mean and median are very different, whatever; but we are generally interested in the more practical definitions. One example is when you have a few outliers … or maybe you have a multimodal distribution (e.g., two different sub communities, two different processes).</p>
<p>But one area is particularly important: <strong>power law distributions</strong> (<a href="https://en.wikipedia.org/wiki/Power_law">Wikipedia</a>), which show up all the time when you're working with data from the web. You have a very <em>very</em> long tail, and a true power-law will show up linearly if you plot it on a log-log scale. Examples in nature include:</p>
<ul>
<li>electrostatic and graviational forces (inverse squares)</li>
<li>distribution of earthquake magnitudes</li>
<li>80/20 rule in the distribution of income / Pareto principle</li>
<li>Relationship between body size and metabolism</li>
</ul>
<p>And then they show up in datasets that we have to deal with:</p>
<ul>
<li>word frequencies in natural language coprora (Zipf's law)</li>
<li>degree distribution in social networks (referred to in the past as the &ldquo;Bieber problem&rdquo; on Twitter, lol) - this was a problem because if you're sharding by user ID, then as soon as Justin Bieber does something it becomes a problem for whatever machines are processing that action …</li>
<li>participation inequality on wikis and forum sites (1% rule)</li>
<li>popularity of websites and content</li>
</ul>
<p>But <strong>why is this a problem?</strong> Computer science has come up with solutions to common cases of this:</p>
<ul>
<li><strong>hot shards</strong> in databases: salt your keys, change the schema</li>
<li><strong>slow load times</strong> for certain users: look for O(n^2) mistakes, e.g., certain users would use their shopping baskets as bookmarks and that caused some quadratic algorithm in the background to crash in the extreme case.</li>
<li><strong>hot mappers</strong> in map-only tasks: repartition randomly</li>
<li><strong>hot reducers</strong> during joins and aggregations: … what do …? This talk will focus on joins (aggregations could be another talk).</li>
</ul>
<h3 id="diagnosing-hot-executors">Diagnosing hot executors</h3>
<p>Usually, you can figure this out by looking at the <em>max</em> runtime of things. The example he gave was where quartiles are 0ms / 3s / 5s / 10s / 55m, which is insane. Scheduler delay was 8ms / 14ms / 19ms / 42ms / 1.1h. We're interesting in figuring out what's happening on the tails.</p>
<p>This turns into a cost problem; while all the executors except one are waiting for something to finish, you could be using those nodes for other problems or tasks.</p>
<h2 id="joins-in-spark">Joins in Spark</h2>
<p>Standard joins in Spark are called &ldquo;shuffle hash joins.&rdquo; Suppose you have two datasets and you want to join on some key; in order to do this, Spark shuffles the rows by key and partitions based on them. This is because each executor has to have the right rows to be able to join them together. The important point is that you can't have one key split over several executors; they all have to be colocated.</p>
<p>That's usually fine, but when you have very skewed data things become uh oh. You'll end up with one executor that has a ton of rows and others that are just waiting on it.</p>
<p>One way around this is a <strong>broadcast join</strong>, which avoids doing a shuffle altogether. It loads one (small) dataset into memory and broadcasts it to all the executors, so the join can just happen in memory; this becomes a <em>map-only task</em>. The problem here is that one of the datasets has to fit in memory, and it can also have reliability issues (sometimes Spark is overoptimistic about what it can broadcast, he turned autobroadcast off).</p>
<h2 id="faster-joins">Faster joins</h2>
<p>We really want to split a single key across multiple tasks, so what we can do is pick a <em>replication factor R</em>. In the <strong>skewed data</strong>, randomly append a number between 0 and R to the existing key, so basically you make a composite key. In the <strong>nonskewed data</strong>, replicate the rows R times and append the replica ID to the original key. Then join on the composite key.</p>
<p>Your skewed dataframe now has the big key split up over partitions, and you have the second dataset copied around that can be joined to everything. This is no longer memory bound, so you're not limited by having to have the dataset in memory.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">replication_ids <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>broadcast(
    spark<span style="color:#f92672">.</span>range(replication_factor)<span style="color:#f92672">.</span>withColumnRenamed(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">id</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">replica_id</span><span style="color:#e6db74">&#34;</span>)
)

<span style="color:#75715e"># Randomly assign rows in skewed data to buckets</span>
skewed_data_tagged <span style="color:#f92672">=</span> skewed_data<span style="color:#f92672">.</span>withColumn(
    <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">composite_key</span><span style="color:#e6db74">&#34;</span>, f<span style="color:#f92672">.</span>concat(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">original_id</span><span style="color:#e6db74">&#34;</span>, f<span style="color:#f92672">.</span>lit(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">@</span><span style="color:#e6db74">&#34;</span>), randint(replication_factor))
)

<span style="color:#75715e"># Replicate uniform data, one copy of each row per bucket</span>
uniform_data_replicated <span style="color:#f92672">=</span> (
    uniform_data
    <span style="color:#f92672">.</span>crossJoin(replication_ids)
    <span style="color:#f92672">.</span>withColumn(
        <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">composite_key</span><span style="color:#e6db74">&#34;</span>,  f<span style="color:#f92672">.</span>concat(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">original_id</span><span style="color:#e6db74">&#34;</span>, f<span style="color:#f92672">.</span>lit(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">@</span><span style="color:#e6db74">&#34;</span>), <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">replica_id</span><span style="color:#e6db74">&#34;</span>)
    )
)

<span style="color:#75715e"># Now you can join on the composite key</span>
joined <span style="color:#f92672">=</span> skewed_data_tagged<span style="color:#f92672">.</span>join(
    uniform_data_replicated,
    on<span style="color:#f92672">=</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">composite_key</span><span style="color:#e6db74">&#34;</span>,
    how<span style="color:#f92672">=</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">inner</span><span style="color:#e6db74">&#34;</span>
)
</code></pre></div><p>This only works for inner and left outer joins … so be careful.</p>
<p><strong>Benchmark:</strong> Generated 100M rows with uniformly-distributed keys, and 100B rows of data with Zipf-distributed keys. A standard inner join ran for <strong>7+ hours</strong> before he killed it (on a super beefy cluster), and a 10x replicated join completed in <strong>1h16m</strong>.</p>
<h3 id="can-we-do-better">Can we do better?</h3>
<p><strong>Differential replication</strong> (which is a term he pulled out of his ass) - well, only the keys that are really common need to be replicated many times. The rare keys don't need to be replicated as much (or at all). Identify the frequent keys before replication, then use a different replication policy for those.</p>
<p>You basically take advantage of Spark's freqItems method that lets you find the most frequent items via an approximation algorithm, which is super powerful.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">replication_factor_high <span style="color:#f92672">=</span> <span style="color:#ae81ff">50</span>
replication_high <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>broadcast(
    spark<span style="color:#f92672">.</span>range(replication_factor_high)<span style="color:#f92672">.</span>withColumnRenamed(<span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">id</span><span style="color:#e6db74">&#39;</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">replica_id</span><span style="color:#e6db74">&#39;</span>)
)
replication_factor_low <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
replication_low <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>broadcast(
    spark<span style="color:#f92672">.</span>range(replication_factor_low)<span style="color:#f92672">.</span>withColumnRenamed(<span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">id</span><span style="color:#e6db74">&#39;</span>, <span style="color:#e6db74"></span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">replica_id</span><span style="color:#e6db74">&#39;</span>)
)

<span style="color:#75715e"># Determine which keys are highly over-represented, broadcast everywhere</span>
top_keys <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>broadcast(
    skewed_data
    <span style="color:#f92672">.</span>freqItems([<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">original_id</span><span style="color:#e6db74">&#34;</span>], <span style="color:#ae81ff">0.0001</span>)  <span style="color:#75715e"># return keys with frequency &gt; this</span>
    <span style="color:#f92672">.</span>select(f<span style="color:#f92672">.</span>explode(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">id_freqItems</span><span style="color:#e6db74">&#34;</span>)<span style="color:#f92672">.</span>alias(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">id_freqItems</span><span style="color:#e6db74">&#34;</span>))
)

uniform_data_top_keys <span style="color:#f92672">=</span> (
    uniform_data
    <span style="color:#f92672">.</span>join(
        top_keys,
        uniform_data<span style="color:#f92672">.</span>original_id <span style="color:#f92672">==</span> top_keys<span style="color:#f92672">.</span>id_freqItems,
        how<span style="color:#f92672">=</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">inner</span><span style="color:#e6db74">&#34;</span>,
    )
    <span style="color:#f92672">.</span>crossJoin(replication_high)
    <span style="color:#f92672">.</span>withColumn(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">composite_key</span><span style="color:#e6db74">&#34;</span>, f<span style="color:#f92672">.</span>concat(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">original_id</span><span style="color:#e6db74">&#34;</span>, f<span style="color:#f92672">.</span>lit(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">@</span><span style="color:#e6db74">&#34;</span>), <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">replica_id</span><span style="color:#e6db74">&#34;</span>))
)

uniform_data_rest <span style="color:#f92672">=</span> (
    uniform_data
    <span style="color:#f92672">.</span>join(
        top_keys,
        uniform_data<span style="color:#f92672">.</span>original_id <span style="color:#f92672">==</span> top_keys<span style="color:#f92672">.</span>id_freqItems,
        how<span style="color:#f92672">=</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">leftanti</span><span style="color:#e6db74">&#34;</span>,
    )
    <span style="color:#f92672">.</span>crossJoin(replication_low)
    <span style="color:#f92672">.</span>withColumn(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">composite_key</span><span style="color:#e6db74">&#34;</span>, f<span style="color:#f92672">.</span>concat(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">original_id</span><span style="color:#e6db74">&#34;</span>, f<span style="color:#f92672">.</span>lit(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">@</span><span style="color:#e6db74">&#34;</span>), <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">replica_id</span><span style="color:#e6db74">&#34;</span>))
)

<span style="color:#75715e"># This is now the entire uniform dataset replicated differentially</span>
uniform_data_replicated <span style="color:#f92672">=</span> uniform_data_top_keys<span style="color:#f92672">.</span>union(uniform_data_rest)

<span style="color:#75715e"># Do the same tagging for skewed data</span>
skewed_data_tagged <span style="color:#f92672">=</span> (
    skewed_data
    <span style="color:#f92672">.</span>join(
        top_keys,  <span style="color:#75715e"># Remember this is broadcasted, no shuffling required</span>
        skewed_data<span style="color:#f92672">.</span>id <span style="color:#f92672">==</span> top_keys<span style="color:#f92672">.</span>id_freqItems,
        how<span style="color:#f92672">=</span><span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">left</span><span style="color:#e6db74">&#34;</span>,
    )
    <span style="color:#f92672">.</span>withColumn(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">replica_id</span><span style="color:#e6db74">&#34;</span>,
        f<span style="color:#f92672">.</span>when(
            f<span style="color:#f92672">.</span>isnull(f<span style="color:#f92672">.</span>col(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">id_freqItems</span><span style="color:#e6db74">&#34;</span>)), randint(replication_factor_low),
        )
        <span style="color:#f92672">.</span>otherwise(randint(replication_factor_high))
    )
    <span style="color:#f92672">.</span>withColumn(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">composite_key</span><span style="color:#e6db74">&#34;</span>, f<span style="color:#f92672">.</span>concat(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">original_id</span><span style="color:#e6db74">&#34;</span>, f<span style="color:#f92672">.</span>lit(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">@</span><span style="color:#e6db74">&#34;</span>), <span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">replica_id</span><span style="color:#e6db74">&#34;</span>))
)
</code></pre></div><p>This lets you replicate very frequent keys more often, and the nonskewed data is replicated if needed. This was a really cool example.</p>
<p><strong>Benchmark</strong>: Generated 100M rows with uniformly-distributed keys, and 100B rows of data with Zipf-distributed keys, just like before. A 10x replicated join completed in <strong>1h16m</strong>, and the 10x/50x differential replication completed in <strong>under 1h</strong>.</p>
<h3 id="partial-broadcasting">Partial broadcasting</h3>
<p>Identify the very common keys in the skewed data, then select these rows from the uniform data and broadcast join those. The rare keys are joined the traditional way (without replication), and then you can union the resulting joined DataFrames.</p>
<p>Intuitively, this seems like a better way of dealing with the case where they are a few specific outliers that you want to single out and treat differently. Probably not better when you have a sliding scale of popularity behavior, but useful sometimes.</p>
<h3 id="dynamic-replication">Dynamic replication</h3>
<p>Get the approximate frequency of every key in the skewed data, and replicate the uniform data proportionally to the key frequency. The intuition is that you replicate by an amount somewhere on a sliding scale between the rarest and most common keys; but this can be hard to make work in practice.</p>
<h3 id="double-sided-skew">Double-sided skew</h3>
<p>Uh oh, what happens if you have two skewed datasets? The intuition is that you have two replication factors, one for each dataset, and create composite keys based off id / left_replica / right_replica … that's an ouch.</p>
<h2 id="checklist">Checklist</h2>
<p>Things to ask yourself before you do this:</p>
<ul>
<li>is the problem just <strong>outliers</strong>? can you safely ignore them?</li>
<li>try the <strong>broadcast join</strong> if possible</li>
<li><strong>look at your data</strong> to get an idea of the distributions</li>
<li><strong>start simple</strong> with a fixed replication factor, then iterate if needed</li>
</ul>
<p>But this can be a really useful thing to do when broadcasts are insufficient. Wow, awesome talk.</p>
    </div>
    <div class="article-footer">
    </div>
  </article>
</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="/about/" title="About Me"><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;Older</span></a>
            </li>
            <li class="next">
                <a href="/spark/graph_algorithms.html"
                    title="Predicting Communities via Graph Algorithms"><span>Newer&nbsp;&nbsp;</span><i
                        class="icon icon-angle-right" aria-hidden="true"></i></a>
            </li>
        </ul>
    </div>
</nav>


</main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="https://github.com/tuchandra" target="_blank" title="github" data-toggle=tooltip data-placement=top >
            <i class="icon icon-github"></i></a></li>
    <li><a href="https://www.linkedin.com/in/tushar-chandra-76a623b6/" target="_blank" title="linkedin" data-toggle=tooltip data-placement=top >
            <i class="icon icon-linkedin"></i></a></li>
    <li><a href="/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
</ul>
  <div class="copyright">
    &copy; 2019 - 2020 Tushar Chandra
    <div class="publishby">
        Theme: <a href="https://github.com/xiaoheiAh/hugo-theme-pure" target="_blank">Hugo Pure</a>.
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/python.min.js"></script><script>
    hljs.configure({
        tabReplace: '    ', 
        classPrefix: ''     
        
    })
    hljs.initHighlightingOnLoad();
</script>

  </body>
</html>
